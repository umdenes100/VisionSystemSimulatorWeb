#!/usr/bin/python3.7

from asyncio import create_subprocess_exec, subprocess, get_event_loop
from collections import namedtuple
from aiohttp import web
import re
import argparse
import uuid
import json
import time
import os

Executable = namedtuple("Executable", ["command", "working_directory"])

BASE_DIR = os.path.dirname(os.path.realpath(__file__))

REQUEST_TYPES = {
    "randomization": Executable(
        command="./randomize",
        working_directory=os.path.join(BASE_DIR, "randomization"),
    ),
    "simulation": Executable(
        command="./simulate",
        working_directory=os.path.join(BASE_DIR, "simulator", "simulator"),
    ),
    "test": Executable(
        command="python3.7 c_program.py",
        working_directory=os.path.join(os.path.dirname(BASE_DIR), "tests"),
    ),
}


functions = {
    "Enes100": ["begin", "updateLocation", "mission", "print", "println"],
    "Tank": [
        "readDistanceSensor",
        "turnOffMotors",
        "setRightMotorPWM",
        "setLeftMotorPWM",
    ],
    "None": ["delay"],
}

regexes = []
replacements = []
for key in functions:
    for function in functions[key]:
        if key == "None":
            reg = f"{function}\s*"
            rep = f"{function}"
        else:
            if function == "println":
                reg = f"Enes100\s*\.\s*HELPER_println\s*"
                rep = f"Enes100.println"
            else:
                reg = f"{key}\s*\.\s*{function}\s*"
                rep = f"{key}.{function}"

        regexes += [re.compile(reg, re.MULTILINE)]
        replacements += [rep]


async def process_command(command, working_directory, data=None):
    start_time = time.time_ns()
    process = await create_subprocess_exec(
        *command.split(),
        cwd=working_directory,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    if data is None:
        stdout, stderr = await process.communicate()
    else:
        stdout, stderr = await process.communicate(
            input=bytes(json.dumps(data), encoding="utf-8")
        )
    print(f"Total Time (ns): {time.time_ns() - start_time}")
    print(f"Return Code: {process.returncode}")
    if stderr:
        return stderr.decode(), False
    # print(f'General Process Info: {vars(process)}')

    return stdout.decode(), True


def preprocess(code):
    # first we need to address the fact that print is subset of println
    println_reg = f"Enes100\s*\.\s*println\s*"
    println_reg = re.compile(println_reg, re.MULTILINE)
    code = println_reg.sub("Enes100.HELPER_println", code)

    for regex, rep in zip(regexes, replacements):
        find = regex.split(code)
        curr_code = ""

        for sector in find:
            if curr_code == "":
                curr_code += sector
            else:
                # if we have a new one that means we need to get the remains of the last function and bop it on
                tack_on = ""
                stack = 0
                done = False
                for i in range(len(sector)):
                    if done:
                        curr_code += sector[i]
                    else:
                        tack_on += sector[i]
                        if sector[i] == "(":
                            stack += 1
                        elif sector[i] == ")":
                            stack -= 1

                        if stack == 0:
                            # we have reached the end of what we need to tack on
                            tack_on = tack_on[1 : len(tack_on) - 1].strip()
                            if tack_on == "":
                                tack_on = "(__LINE__ - 2)"
                            else:
                                tack_on = "(__LINE__ - 2, " + tack_on + ")"

                            curr_code += rep + tack_on
                            done = True
        code = curr_code

    return code


async def middleware(request):
    if "json" in request.url.query:
        request = json.loads(request.url.query["json"])
    else:
        request = dict(request.rel_url.query)

    request["id"] = uuid.uuid4().hex
    print(f"Request: {json.dumps(request, indent=2)}")
    command, working_directory = REQUEST_TYPES[request["type"]]

    if request["type"] == "simulation":
        request["code"] = preprocess(request["code"])

    result, success = await process_command(command, working_directory, request)
    if request["type"] == "simulation" and success:
        result = result[:-2] + result[-1:]  # Removing trailing comma.

    try:
        result_json = json.loads(result)
    except json.decoder.JSONDecodeError:
        print(f"Invalid JSON: Received result {result}")
        print("ERROR.")
        return

    # print(f'Output: {json.dumps(result_json, indent=2)}')
    # print()
    return web.json_response(
        result_json, headers={"Access-Control-Allow-Origin": "*"}
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--host", type=str, default="0.0.0.0", help="e.g. 0.0.0.0"
    )
    parser.add_argument("--port", type=int, default=8888, help="e.g. 8888")
    args = parser.parse_args()

    app = web.Application()
    app.add_routes([web.get("/", middleware)])
    web.run_app(app, host=args.host, port=args.port)
